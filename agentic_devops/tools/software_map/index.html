<!DOCTYPE html>
<html>
<head>
    <title>Feature Map Browser</title>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f8f9fa;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Title Bar */
        #title-bar {
            background: #343a40;
            color: white;
            padding: 10px 20px;
            font-size: 18px;
            font-weight: bold;
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }

        /* Tab Navigation */
        #tab-bar {
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            padding: 0 10px;
            align-items: flex-end;
            height: 50px;
            flex-shrink: 0;
        }
        .tab {
            padding: 8px 20px;
            background: #dee2e6;
            border: 1px solid #ced4da;
            border-bottom: none;
            border-radius: 6px 6px 0 0;
            margin-right: 5px;
            font-size: 20px;
            font-weight: bold;
            color: #495057;
            cursor: pointer;
            transition: all 0.2s;
            height: 30px;
            display: flex;
            align-items: center;
        }
        .tab.active {
            background: #f8f9fa;
            color: #000;
            height: 40px;
            margin-bottom: -1px;
            border-color: #dee2e6;
            position: relative;
            z-index: 2;
        }

        #container {
            width: 100%;
            flex-grow: 1;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        #graph-output {
            width: 100%;
            height: 100%;
        }
        #graph-output svg {
            width: 100% !important;
            height: 100% !important;
        }
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            font-size: 11px;
            color: #888;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            pointer-events: none;
            z-index: 10;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        button {
            padding: 8px 16px;
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
        }
        button:hover { background: #0056b3; }
        
        /* Subgraph title node styling */
        .node.subgraphTitle rect {
            fill: none !important;
            stroke: none !important;
        }
        .node.subgraphTitle .nodeLabel {
            font-size: 36px !important;
            font-weight: bold !important;
            color: #111 !important;
            cursor: default !important;
            padding: 20px !important;
        }
        
        /* Subgraph styling overrides */
        .subgraph {
            fill: #e6e6e6 !important; /* 10% grey */
            stroke: #cccccc !important;
        }
        .cluster rect {
            fill: #e6e6e6 !important;
            stroke: #cccccc !important;
        }
        
        /* Nested inner subgraphs should be transparent and borderless */
        [id*="_inner"] rect, [id*="-inner-"] rect, .cluster[id*="_inner"] rect {
            fill: none !important;
            stroke: none !important;
        }
        
        /* Class Diagram Styles */
        /* Removed as Class Map functionality is disabled */

        /* Modal Styles */
        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 100;
            backdrop-filter: blur(2px);
            align-items: center;
            justify-content: center;
        }
        #modal-content {
            background: white;
            width: 80%;
            height: 85%;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            animation: modalFadeIn 0.2s ease-out;
        }
        @keyframes modalFadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        #modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fcfcfc;
        }
        #modal-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            flex-grow: 1;
            text-align: center;
        }
        #modal-close {
            position: absolute;
            right: 20px;
            top: 15px;
            background: none;
            border: none;
            color: #666;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            padding: 5px 10px;
            line-height: 1;
            transition: color 0.2s;
        }
        #modal-close:hover { color: #000; background: none; }
        
        #modal-body {
            padding: 30px;
            overflow-y: auto;
            flex-grow: 1;
            line-height: 1.6;
            color: #24292e;
        }

        /* Markdown Styles within Modal */
        #modal-body h1, #modal-body h2, #modal-body h3 { border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; margin-top: 24px; }
        #modal-body h1 { font-size: 2em; margin-top: 0; }
        #modal-body pre { background: #f6f8fa; padding: 16px; border-radius: 6px; overflow: auto; }
        #modal-body code { font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace; font-size: 85%; }
        #modal-body blockquote { color: #6a737d; border-left: 0.25em solid #dfe2e5; padding: 0 1em; margin: 0; }
        #modal-body table { border-collapse: collapse; width: 100%; margin: 16px 0; }
        #modal-body table th, #modal-body table td { padding: 6px 13px; border: 1px solid #dfe2e5; }
        #modal-body table tr:nth-child(2n) { background-color: #f6f8fa; }

        /* Highlight Styles */
        .node.highlighted {
            filter: brightness(0.9);
            stroke-width: 3px !important;
        }

        /* Hide ALL edges connected to title nodes (Layout Helpers) */
        [class*="LS-title_"] path, 
        [class*="LE-title_"] path,
        [class*="LS-title_"] .path,
        [class*="LE-title_"] .path {
            stroke-width: 0 !important;
            stroke: none !important;
            opacity: 0 !important;
            fill: none !important;
        }
        
        [class*="LS-title_"] .markerPath, 
        [class*="LE-title_"] .markerPath,
        [class*="LS-title_"] marker,
        [class*="LE-title_"] marker {
            display: none !important;
            opacity: 0 !important;
        }

        .edgePath.highlighted path {
            stroke-width: 3px !important;
            stroke: #007bff !important;
        }
        .edgePath.dimmed {
            opacity: 0.1;
        }
        .node.dimmed {
            opacity: 0.2;
        }
    </style>
</head>
<body>
    <div id="title-bar">
        Feature Map Browser
    </div>
    <div id="tab-bar">
        <div id="tab-lpad" class="tab active" onclick="switchTab('lpad')">LPad</div>
        <div id="tab-agentic" class="tab" onclick="switchTab('agentic')">Agentic Devops</div>
    </div>

    <div id="container">
        <div id="status">Connecting...</div>
        
        <div id="controls">
            <button onclick="resetZoom()">Fit to Screen</button>
            <div style="font-size: 11px; color: #666; text-align: center;">
                Scroll: Zoom<br>Drag: Pan
            </div>
        </div>

        <div id="graph-output" class="mermaid"></div>
    </div>

    <!-- Feature Detail Modal -->
    <div id="modal-overlay" onclick="closeModal(event)">
        <div id="modal-content" onclick="event.stopPropagation()">
            <div id="modal-header">
                <div id="modal-title">Feature Details</div>
                <button id="modal-close" onclick="closeModal()">X</button>
            </div>
            <div id="modal-body">
                <!-- Content will be injected here -->
            </div>
        </div>
    </div>

    <script>
        mermaid.initialize({ 
            startOnLoad: false,
            securityLevel: 'loose',
            theme: 'neutral',
            flowchart: { useMaxWidth: true, htmlLabels: true }
        });

        let lastMtime = 0;
        let panZoom = null;
        let currentTab = 'lpad';

        function switchTab(tab) {
            if (currentTab === tab) return;
            
            // UI Update
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');
            
            currentTab = tab;
            lastMtime = 0; // Force refresh
            updateGraph();
        }

        function saveZoomState() {
            if (panZoom) {
                const state = {
                    pan: panZoom.getPan(),
                    zoom: panZoom.getZoom()
                };
                localStorage.setItem(`lpad_software_map_zoom_${currentTab}`, JSON.stringify(state));
            }
        }

        function getZoomState() {
            const saved = localStorage.getItem(`lpad_software_map_zoom_${currentTab}`);
            return saved ? JSON.parse(saved) : null;
        }

        function resetZoom() {
            localStorage.removeItem(`lpad_software_map_zoom_${currentTab}`);
            if (panZoom) {
                panZoom.resize();
                panZoom.fit();
                panZoom.center();
            }
        }

        window.addEventListener('resize', resetZoom);

        // Prevent browser from zooming when pinch-zooming on trackpad
        window.addEventListener('wheel', function(e) {
            if (e.ctrlKey) {
                e.preventDefault();
            }
        }, { passive: false });

        async function updateGraph() {
            try {
                const response = await fetch(`/api/graph?type=${currentTab}`);
                const data = await response.json();
                
                if (data.mtime !== lastMtime) {
                    const output = document.getElementById('graph-output');
                    
                    // Save current state before destroying
                    saveZoomState();

                    // Store content for highlighting logic
                    window.currentGraphContent = data.content;

                    // Render new graph
                    const { svg } = await mermaid.render('mermaid-svg', data.content);
                    output.innerHTML = svg;
                    
                    const svgElement = document.getElementById('mermaid-svg');
                    // Remove fixed dimensions
                    svgElement.removeAttribute('width');
                    svgElement.removeAttribute('height');
                    svgElement.style.maxWidth = 'none';

                    // Add Click Listeners to Nodes
                    addNodeClickListeners();

                    // Re-initialize pan-zoom
                    if (panZoom) panZoom.destroy();
                    panZoom = svgPanZoom('#mermaid-svg', {
                        zoomEnabled: true,
                        controlIconsEnabled: false,
                        fit: true,
                        center: true,
                        minZoom: 0.05,
                        maxZoom: 10,
                        dblClickZoomEnabled: false,
                        onZoom: saveZoomState,
                        onPan: saveZoomState,
                        beforePan: function(oldPan, newPan) {
                            const gutterWidth = 100;
                            const gutterHeight = 100;
                            const sizes = this.getSizes();
                            
                            const leftLimit = gutterWidth - (sizes.viewBox.width * sizes.realZoom);
                            const rightLimit = sizes.width - gutterWidth;
                            const topLimit = gutterHeight - (sizes.viewBox.height * sizes.realZoom);
                            const bottomLimit = sizes.height - gutterHeight;

                            return {
                                x: Math.max(leftLimit, Math.min(rightLimit, newPan.x)),
                                y: Math.max(topLimit, Math.min(bottomLimit, newPan.y))
                            };
                        }
                    });

                    // Restore state if available
                    const savedState = getZoomState();
                    if (savedState && savedState.pan && savedState.zoom) {
                        panZoom.zoom(savedState.zoom);
                        panZoom.pan(savedState.pan);
                    } else {
                        // Small delay to ensure browser has handled SVG sizing/layout
                        setTimeout(resetZoom, 50);
                    }

                    lastMtime = data.mtime;
                    document.getElementById('status').innerText = 'Live: ' + new Date().toLocaleTimeString();
                } else {
                    document.getElementById('status').innerText = 'Live: ' + new Date().toLocaleTimeString();
                }
            } catch (err) {
                console.error('Failed to update graph:', err);
                document.getElementById('status').innerText = 'Connection Lost';
            }
        }

        function addNodeClickListeners() {
            const nodes = document.querySelectorAll('.node');
            const graphMap = {};

            if (window.currentGraphContent) {
                const lines = window.currentGraphContent.split('\n');
                lines.forEach(line => {
                    const match = line.match(/\s+([^\s\-\>\=\.<]+)\s*[-=.]{2,}>+.*?\s*([^\s\-\>\=\.<]+)/);
                    if (match) {
                        const src = match[1];
                        const dst = match[2];
                        
                        if (!graphMap[src]) graphMap[src] = { neighbors: new Set() };
                        if (!graphMap[dst]) graphMap[dst] = { neighbors: new Set() };
                        
                        graphMap[src].neighbors.add(dst);
                        graphMap[dst].neighbors.add(src);
                    }
                });
            }

            const getCoreId = (domId) => {
                const match = domId.match(/flowchart-(.*?)-\d+/);
                return match ? match[1] : domId;
            };

            nodes.forEach(node => {
                if (node.classList.contains('subgraphTitle')) return;

                node.style.cursor = 'pointer';
                const coreId = getCoreId(node.id);
                
                node.addEventListener('mouseenter', () => {
                    const relatedNodes = new Set([node.id]);
                    const coreNeighbors = graphMap[coreId]?.neighbors || new Set();

                    nodes.forEach(n => {
                        const nCore = getCoreId(n.id);
                        if (coreNeighbors.has(nCore)) {
                            relatedNodes.add(n.id);
                        }
                    });

                    nodes.forEach(n => {
                        if (relatedNodes.has(n.id)) {
                            n.classList.add('highlighted');
                        } else {
                            n.classList.add('dimmed');
                        }
                    });
                    
                    const edges = document.querySelectorAll('.edgePath');
                    edges.forEach(edge => {
                         const classes = edge.className.baseVal;
                         let isConnected = false;
                         coreNeighbors.forEach(neighbor => {
                             const hasSrc = new RegExp(`LS-${coreId}(\\s|$)`).test(classes) || new RegExp(`LS-${neighbor}(\\s|$)`).test(classes);
                             const hasDst = new RegExp(`LE-${coreId}(\\s|$)`).test(classes) || new RegExp(`LE-${neighbor}(\\s|$)`).test(classes);
                             if (hasSrc && hasDst) isConnected = true;
                         });

                         if (isConnected) {
                             edge.classList.add('highlighted');
                         } else {
                             edge.classList.add('dimmed');
                         }
                    });
                });

                node.addEventListener('mouseleave', () => {
                    nodes.forEach(n => n.classList.remove('highlighted', 'dimmed'));
                    const edges = document.querySelectorAll('.edgePath');
                    edges.forEach(e => e.classList.remove('highlighted', 'dimmed'));
                });

                node.addEventListener('click', (e) => {
                    const html = node.innerHTML;
                    const match = html.match(/<small>(.*?)<\/small>/i);
                    if (match && match[1]) {
                        const filename = match[1].replace(/<[^>]*>?/gm, '').trim();
                        openFeatureModal(filename);
                        return;
                    }
                });
            });
        }

        async function openFeatureModal(filename) {
            const modal = document.getElementById('modal-overlay');
            const body = document.getElementById('modal-body');
            const title = document.getElementById('modal-title');
            
            body.innerHTML = '<div style="text-align:center; padding: 20px;">Loading...</div>';
            title.innerText = filename;
            modal.style.display = 'flex';

            try {
                const response = await fetch(`/api/feature/${filename}`);
                if (!response.ok) throw new Error("File not found");
                const text = await response.text();

                const labelMatch = text.match(/> Label: "(.*?)"/);
                const friendlyTitle = labelMatch ? labelMatch[1] : filename;
                title.innerText = friendlyTitle;

                const htmlContent = marked.parse(text);
                body.innerHTML = htmlContent;

                body.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightElement(block);
                });

                document.getElementById('modal-content').focus();

            } catch (e) {
                body.innerHTML = `<div style="color:red; text-align:center;">Error loading file: ${e.message}</div>`;
            }
        }

        function closeModal(event) {
            if (event && event.target.id !== 'modal-overlay' && event.target.id !== 'modal-close') return;
            document.getElementById('modal-overlay').style.display = 'none';
        }

        document.addEventListener('keydown', (e) => {
            if (document.getElementById('modal-overlay').style.display === 'flex') {
                if (e.key === 'Escape') closeModal();
            }
        });

        setInterval(updateGraph, 2000);
        updateGraph();
    </script>
</body>
</html>
